\textbf{不修改序列的操作}

\noindent \textbf{批量操作} 

\textit{在标头 \lstinline{<algorithm>} 定义}

\noindent \lstinline{for_each}

应⽤⼀元函数对象到范围中元素 (函数模板)

\noindent \lstinline{ranges::for_each} (C++20) 

应⽤⼀元函数对象到范围中元素 (算法函数对象)

\noindent \lstinline{for_each_n} (C++17) 

应⽤函数对象到序列的前 N 个元素 (函数模板)

\noindent \lstinline{ranges::for_each_n} (C++20) 

应⽤函数对象到序列的前 N 个元素 (算法函数对象)

\noindent \textbf{搜索操作} 

\textit{在标头 \lstinline{<algorithm>} 定义}

\noindent \lstinline{all_of} (C++11)

\noindent \lstinline{any_of} (C++11)

\noindent \lstinline{none_of} (C++11)

检查谓词是否对范围中所有、任⼀或⽆元素为 \lstinline{true} (函数模板)

\noindent \lstinline{ranges::all_of} (C++20)

\noindent \lstinline{ranges::any_of} (C++20)

\noindent \lstinline{ranges::none_of} (C++20)

检查谓词是否对范围中所有、任⼀或⽆元素为 \lstinline{true} (算法函数对象)

\noindent \lstinline{ranges::contains} (C++23)

\noindent \lstinline{ranges::contains_subrange} (C++23)

检查范围是否包含给定元素或⼦范围 (算法函数对象)

\noindent \lstinline{find}

\noindent \lstinline{find_if}

\noindent \lstinline{find_if_not} (C++11)

查找⾸个满⾜特定条件的元素 (函数模板)

\noindent \lstinline{ranges::find} (C++20)

\noindent \lstinline{ranges::find_if} (C++20)

\noindent \lstinline{ranges::find_if_not} (C++20)

查找⾸个满⾜特定条件的元素 (算法函数对象)

\noindent \lstinline{ranges::find_last} (C++23)

\noindent \lstinline{ranges::find_last_if} (C++23)

\noindent \lstinline{ranges::find_last_if_not} (C++23)

查找最后⼀个满⾜特定条件的元素 (算法函数对象)

\noindent \lstinline{find_end}

查找元素序列在特定范围中最后⼀次出现 (函数模板)

\noindent \lstinline{ranges::find_end} (C++20)

查找元素序列在特定范围中最后⼀次出现 (算法函数对象)

\noindent \lstinline{find_first_of} 

搜索⼀组元素中任⼀元素 (函数模板)

\noindent \lstinline{ranges::find_first_of} (C++20)

搜索⼀组元素中任⼀元素 (算法函数对象)

\noindent \lstinline{adjacent_find}

查找⾸对相同（或满⾜给定谓词）的相邻元素 (函数模板)

\noindent \lstinline{ranges::adjacent_find} (C++20) 

查找⾸对相同（或满⾜给定谓词）的相邻元素 (算法函数对象)

\noindent \lstinline{count}

\noindent \lstinline{count_if}

返回满⾜特定条件的元素数⽬ (函数模板)

\noindent \lstinline{ranges::count} (C++20)

\noindent \lstinline{ranges::count_if} (C++20)

返回满⾜特定条件的元素数⽬ (算法函数对象)


\noindent \lstinline{mismatch}

查找两个范围的⾸个不同之处 (函数模板)

\noindent \lstinline{ranges::mismatch} (C++20)

查找两个范围的⾸个不同之处 (算法函数对象)

\noindent \lstinline{equal}

判断两组元素是否相同 (函数模板)

\noindent \lstinline{ranges::equal} (C++20)

判断两组元素是否相同 (算法函数对象)

\noindent \lstinline{search}

搜索元素范围的⾸次出现 (函数模板)

\noindent \lstinline{ranges::search} (C++20)

搜索元素范围的⾸次出现 (算法函数对象)

\noindent \lstinline{search_n}

搜索元素在范围中⾸次连续若⼲次出现 (函数模板)

\noindent \lstinline{ranges::search_n} (C++20) 

搜索元素在范围中⾸次连续若⼲次出现 (算法函数对象)

\noindent \lstinline{ranges::starts_with} (C++23)

检查⼀个范围是否始于另⼀范围 (算法函数对象)

\noindent \lstinline{ranges::ends_with} (C++23)

检查⼀个范围是否终于另⼀范围 (算法函数对象)

\noindent \textbf{折叠操作} (C++23 起)

\textit{在标头 \lstinline{<algorithm>} 定义}

\noindent \lstinline{ranges::fold_left} (C++23)

左折叠范围中元素 (算法函数对象)

\noindent \lstinline{ranges::fold_left_first} (C++23)

以⾸元素为初值左折叠范围中元素 (算法函数对象)

\noindent \lstinline{ranges::fold_right} (C++23)

右折叠范围中元素 (算法函数对象)

\noindent \lstinline{ranges::fold_right_last} (C++23)

以末元素为初值右折叠范围中元素 (算法函数对象)

\noindent \lstinline{ranges::fold_left_with_iter} (C++23) 

左折叠范围中元素，并返回 \lstinline{pair}（迭代器，值） (算法函数对象)

\noindent \lstinline{ranges::fold_left_first_with_iter} (C++23) 

以⾸元素为初值左折叠范围中元素，并返回 \lstinline{pair}（迭代器，optional） (算法函数对象)

\textbf{修改序列的操作}

\noindent \textbf{复制操作} 

\textit{在标头 \lstinline{<algorithm>} 定义}

\noindent \lstinline{copy}

\noindent \lstinline{copy_if} (C++11)

复制范围中元素到新位置 (函数模板)

\noindent \lstinline{ranges::copy} (C++20)

\noindent \lstinline{ranges::copy_if} (C++20)

复制范围中元素到新位置 (算法函数对象)

\noindent \lstinline{copy_n} (C++11)

复制若⼲元素到新位置 (函数模板)

\noindent \lstinline{ranges::copy_n} (C++20)

复制若⼲元素到新位置 (算法函数对象)

\noindent \lstinline{copy_backward} 

从后往前复制范围中元素 (函数模板)

\noindent \lstinline{ranges::copy_backward} (C++20)

从后往前复制范围中元素 (算法函数对象)

\noindent \lstinline{move} (C++11)

将范围中元素移到新位置 (函数模板)

\noindent \lstinline{ranges::move} (C++20)

将范围中元素移到新位置 (算法函数对象)

\noindent \lstinline{move_backward} (C++11)

从后往前将范围中元素移到新位置 (函数模板)

\noindent \lstinline{ranges::move_backward} (C++20)

从后往前将范围中元素移到新位置 (算法函数对象)

\noindent \textbf{交换操作} 

\textit{在标头 \lstinline{<algorithm>} 定义 (C++11 前)}

\textit{在标头 \lstinline{<utility>} 定义 (C++11 起)}

\textit{在标头 \lstinline{<string_view>} 定义}

\noindent \lstinline{swap} 

\textit{在标头 \lstinline{<algorithm>} 定义}

交换两个对象的值 (函数模板)

\noindent \lstinline{swap_ranges} 

交换两个范围的元素 (函数模板)

\noindent \lstinline{ranges::swap_ranges} (C++20) 

交换两个范围的元素 (算法函数对象)

\noindent \lstinline{iter_swap} 

交换两个迭代器所指向的元素 (函数模板)

\noindent \textbf{变换操作}

\textit{在标头 \lstinline{<algorithm>} 定义}

\noindent \lstinline{transform}

应⽤函数到元素范围，并在⽬标范围存储结果 (函数模板)

\noindent \lstinline{ranges::transform} (C++20)

应⽤函数到元素范围 (算法函数对象)

\noindent \lstinline{replace}

\noindent \lstinline{replace_if}

替换所有满⾜特定条件的值为另⼀个值 (函数模板)

\noindent \lstinline{ranges::replace} (C++20)

\noindent \lstinline{ranges::replace_if} (C++20)

替换所有满⾜特定条件的值为另⼀个值 (算法函数对象)

\noindent \lstinline{replace_copy}

\noindent \lstinline{replace_copy_if}

复制范围，并将满⾜特定条件的元素替换为另⼀个值 (函数模板)

\noindent \lstinline{ranges::replace_copy} (C++20)

\noindent \lstinline{ranges::replace_copy_if} (C++20)

复制范围，并将满⾜特定条件的元素替换为另⼀个值 (算法函数对象)

\noindent \textbf{生成操作}

\textit{在标头 \lstinline{<algorithm>} 定义}

\noindent \lstinline{fill}

以复制的⽅式赋给定值到范围中所有元素 (函数模板)

\noindent \lstinline{ranges::fill} (C++20)

赋给定值到范围中元素 (算法函数对象)

\noindent \lstinline{fill_n}

以复制的⽅式赋给定值到范围中 N 个元素 (函数模板)

\noindent \lstinline{ranges::fill_n} (C++20)

赋给定值到若⼲元素 (算法函数对象)

\noindent \lstinline{generate}

赋连续函数调⽤结果到范围中所有元素 (函数模板)

\noindent \lstinline{ranges::generate} (C++20)

将函数结果保存到范围中 (算法函数对象)

\noindent \lstinline{generate_n}

赋连续函数调⽤结果到范围中 N 个元素 (函数模板)

\noindent \lstinline{ranges::generate_n} (C++20)

保存 N 次函数应⽤的结果 (算法函数对象)

\noindent \textbf{移除操作}

\textit{在标头 \lstinline{<algorithm>} 定义}


\noindent \lstinline{remove}

\noindent \lstinline{remove_if}

移除满⾜特定条件的元素 (函数模板)

\noindent \lstinline{ranges::remove} (C++20)

\noindent \lstinline{ranges::remove_if} (C++20)

移除满⾜特定条件的元素 (算法函数对象)

\noindent \lstinline{remove_copy}

\noindent \lstinline{remove_copy_if}

复制范围并忽略满⾜特定条件的元素 (函数模板)

\noindent \lstinline{ranges::remove_copy} (C++20)

\noindent \lstinline{ranges::remove_copy_if} (C++20)

复制范围并忽略满⾜特定条件的元素 (算法函数对象)

\noindent \lstinline{unique}

移除范围中连续重复元素 (函数模板)

\noindent \lstinline{ranges::unique} (C++20)

移除范围中连续重复元素 (算法函数对象)

\noindent \lstinline{unique_copy}

创建某范围的不含连续重复元素的副本 (函数模板)

\noindent \lstinline{ranges::unique_copy} (C++20)

创建某范围的不含连续重复元素的副本 (算法函数对象)


\noindent \textbf{顺序变更操作}

\textit{在标头 \lstinline{<algorithm>} 定义}


\noindent \lstinline{reverse}

逆转范围中的元素顺序 (函数模板)

\noindent \lstinline{ranges::reverse} (C++20)

逆转范围中的元素顺序 (算法函数对象)

\noindent \lstinline{reverse_copy} 

创建范围的逆向副本 (函数模板)

\noindent \lstinline{ranges::reverse_copy} (C++20) 

创建范围的逆向副本 (算法函数对象)

\noindent \lstinline{rotate} 

旋转范围中的元素顺序 (函数模板)

\noindent \lstinline{ranges::rotate} (C++20)

旋转范围中的元素顺序 (算法函数对象)

\noindent \lstinline{rotate_copy}

复制并旋转元素范围 (函数模板)

\noindent \lstinline{ranges::rotate_copy} (C++20)

复制并旋转元素范围 (算法函数对象)

\noindent \lstinline{shift_left} (C++20)

\noindent \lstinline{shift_right} (C++20) 

迁移范围中元素 (函数模板)

\noindent \lstinline{ranges::shift_left} (C++23)

\noindent \lstinline{ranges::shift_right} (C++23)

迁移范围中元素 (算法函数对象)

\noindent \lstinline{random_shuffle} (C++17 前)

\noindent \lstinline{shuffle} (C++11)

随机重排范围中元素 (函数模板)

\noindent \lstinline{ranges::shuffle} (C++20)

随机重排范围中元素 (算法函数对象)

\noindent \textbf{采样操作}

\textit{在标头 \lstinline{<algorithm>} 定义}

\noindent \lstinline{sample} (C++17)

从序列中随机选择 N 个元素 (函数模板)

\noindent \lstinline{ranges::sample} (C++20)

从序列中随机选择 N 个元素 (算法函数对象)

\textbf{排序和相关操作}

\noindent \textbf{要求}

部分算法要求由实参表示的序列“已排序”或“已划分”。未满⾜要求时⾏为未定义。

序列 \lstinline{[start, finish)} 在满⾜以下条件时已按表达式 \lstinline{f(e)} 划分：存在⼀个整数 \lstinline{n}，使得对于 \lstinline{[0, std::distance(start, finish))} 中的所有整数 \lstinline{i}， \lstinline{f(*(start + i))} 当且仅当 \lstinline{i < n} 时是 \lstinline{true}。

\noindent \textbf{划分操作}

\textit{在标头 \lstinline{<algorithm>} 定义}


\noindent \lstinline{is_partitioned} (C++11)

判断范围是否已按给定谓词划分 (函数模板)

\noindent \lstinline{ranges::is_partitioned} (C++20)

判断范围是否已按给定谓词划分 (算法函数对象)

\noindent \lstinline{partition} 

将范围中元素分为两组 (函数模板)

\noindent \lstinline{ranges::partition} (C++20)

将范围中元素分为两组 (算法函数对象)

\noindent \lstinline{partition_copy} (C++11)

复制范围并将元素分为两组 (函数模板)

\noindent \lstinline{ranges::partition_copy} (C++20)

复制范围并将元素分为两组 (算法函数对象)

\noindent \lstinline{stable_partition}

将元素分为两组，同时保留其相对顺序 (函数模板)

\noindent \lstinline{ranges::stable_partition} (C++20)

将元素分为两组，同时保留其相对顺序 (算法函数对象)

\noindent \lstinline{partition_point} (C++11)

定位已划分范围的划分点 (函数模板)

\noindent \lstinline{ranges::partition_point} (C++20)

定位已划分范围的划分点 (算法函数对象)

\noindent \textbf{排序操作}

\textit{在标头 \lstinline{<algorithm>} 定义}


\noindent \lstinline{sort}

将范围按升序排序 (函数模板)

\noindent \lstinline{ranges::sort} (C++20)

将范围按升序排序 (算法函数对象)

\noindent \lstinline{stable_sort}

将范围中元素排序，同时保持相等元之间的顺序 (函数模板)

\noindent \lstinline{ranges::stable_sort} (C++20)

将范围中元素排序，同时保持相等元之间的顺序 (算法函数对象)

\noindent \lstinline{partial_sort}

将范围中前 N 个元素排序 (函数模板)

\noindent \lstinline{ranges::partial_sort} (C++20)

将范围中前 N 个元素排序 (算法函数对象)

\noindent \lstinline{partial_sort_copy}

复制范围中元素并部分排序 (函数模板)

\noindent \lstinline{ranges::partial_sort_copy} (C++20)

复制范围中元素并部分排序 (算法函数对象)

\noindent \lstinline{is_sorted} (C++11)

检查范围是否已按升序排列 (函数模板)

\noindent \lstinline{ranges::is_sorted} (C++20)

检查范围是否已按升序排列 (算法函数对象)

\noindent \lstinline{is_sorted_until} (C++11)

找出最⼤的有序⼦范围 (函数模板)

\noindent \lstinline{ranges::is_sorted_until} (C++20)

找出最⼤的有序⼦范围 (算法函数对象)

\noindent \lstinline{nth_element}

将给定范围部分排序，确保其按给定元素划分 (函数模板)

\noindent \lstinline{ranges::nth_element} (C++20)

将给定范围部分排序，确保其按给定元素划分 (算法函数对象)

\noindent \textbf{二分搜素操作（在已划分范围上）}

\textit{在标头 \lstinline{<algorithm>} 定义}


\noindent \lstinline{lower_bound}

返回⾸个不⼩于给定值的元素的迭代器 (函数模板)

\noindent \lstinline{ranges::lower_bound} (C++20)

返回⾸个不⼩于给定值的元素的迭代器 (算法函数对象)

\noindent \lstinline{upper_bound}

返回⾸个⼤于给定值的元素的迭代器 (函数模板)

\noindent \lstinline{ranges::upper_bound} (C++20)

返回⾸个⼤于给定值的元素的迭代器 (算法函数对象)

\noindent \lstinline{equal_range}

返回匹配特定键值的元素范围 (函数模板)

\noindent \lstinline{ranges::equal_range} (C++20)

返回匹配特定键值的元素范围 (算法函数对象)

\noindent \lstinline{binary_search} 

判断元素是否在偏序范围中 (函数模板)

\noindent \lstinline{ranges::binary_search} (C++20)

判断元素是否在偏序范围中 (算法函数对象)


\noindent \textbf{集合操作（在已排序范围上）}

\textit{在标头 \lstinline{<algorithm>} 定义}


\noindent \lstinline{includes}

当⼀个序列是另⼀个的⼦序列时返回 \lstinline{true} (函数模板)

\noindent \lstinline{ranges::includes} (C++20) 

当⼀个序列是另⼀个的⼦序列时返回 \lstinline{true} (算法函数对象)

\noindent \lstinline{set_union} 

计算两个集合的并集 (函数模板)

\noindent \lstinline{ranges::set_union} (C++20) 

计算两个集合的并集 (算法函数对象)

\noindent \lstinline{set_intersection} 

计算两个集合的交集 (函数模板)

\noindent \lstinline{ranges::set_intersection} (C++20) 

计算两个集合的交集 (算法函数对象)

\noindent \lstinline{set_difference} 

计算两个集合的差集 (函数模板)

\noindent \lstinline{ranges::set_difference} (C++20) 

计算两个集合的差集 (算法函数对象)

\noindent \lstinline{set_symmetric_difference}

计算两个集合的对称差 (函数模板)

\noindent \lstinline{ranges::set_symmetric_difference} (C++20)

计算两个集合的对称差 (算法函数对象)

\noindent \textbf{归并操作（在已排序范围上）}

\textit{在标头 \lstinline{<algorithm>} 定义}

\noindent \lstinline{merge}

合并两个有序范围 (函数模板)

\noindent \lstinline{ranges::merge} (C++20)

合并两个有序范围 (算法函数对象)

\noindent \lstinline{inplace_merge}

就地合并两个有序范围 (函数模板)

\noindent \lstinline{ranges::inplace_merge} (C++20)

就地合并两个有序范围 (算法函数对象)

\noindent \textbf{堆操作}

(C++20 前) 随机访问范围 \lstinline{[first, last)} 在满⾜以下条件时是⼀个关于⽐较器 \lstinline{comp} 的堆：对于 \lstinline{(0, last - first)} 中的所有整数 \lstinline{i}， \lstinline{bool(comp(first[(i - 1) / 2], first[i]))} 都是 \lstinline{false}。

\textit{在标头 \lstinline{<algorithm>} 定义}


\noindent \lstinline{push_heap}

添加元素到最⼤堆 (函数模板)

\noindent \lstinline{ranges::push_heap} (C++20)

添加元素到最⼤堆 (算法函数对象)

\noindent \lstinline{pop_heap}

移除最⼤堆中最⼤元 (函数模板)

\noindent \lstinline{ranges::pop_heap} (C++20)

移除最⼤堆中最⼤元 (算法函数对象)

\noindent \lstinline{make_heap}

从元素范围创建最⼤堆 (函数模板)

\noindent \lstinline{ranges::make_heap} (C++20)

从元素范围创建最⼤堆 (算法函数对象)

\noindent \lstinline{sort_heap}

将最⼤堆变成按升序排序的元素范围 (函数模板)

\noindent \lstinline{ranges::sort_heap} (C++20)

将最⼤堆变成按升序排序的元素范围 (算法函数对象)

\noindent \lstinline{is_heap}

检查给定范围是否为最⼤堆 (函数模板)

\noindent \lstinline{ranges::is_heap} (C++20)

检查给定范围是否为最⼤堆 (算法函数对象)

\noindent \lstinline{is_heap_until} (C++11)

查找能成为最⼤堆的最⼤⼦范围 (函数模板)

\noindent \lstinline{ranges::is_heap_until} (C++20)

查找能成为最⼤堆的最⼤⼦范围 (算法函数对象)

\noindent \textbf{最小/最大操作}

\textit{在标头 \lstinline{<algorithm>} 定义}


\noindent \lstinline{max} 

返回给定值中较⼤者 (函数模板)

\noindent \lstinline{ranges::max} (C++20) 

返回给定值中较⼤者 (算法函数对象)

\noindent \lstinline{max_element}

返回范围中最⼤元 (函数模板)

\noindent \lstinline{ranges::max_element} (C++20)

返回范围中最⼤元 (算法函数对象)

\noindent \lstinline{min}

返回给定值中较⼩者 (函数模板)

\noindent \lstinline{ranges::min} (C++20)

返回给定值中较⼩者 (算法函数对象)

\noindent \lstinline{min_element}

返回范围中最⼩元 (函数模板)

\noindent \lstinline{ranges::min_element} (C++20)

返回范围中最⼩元 (算法函数对象)

\noindent \lstinline{minmax} (C++11)

返回两个元素间的较⼩者和较⼤者 (函数模板)

\noindent \lstinline{ranges::minmax} (C++20)

返回两个元素间的较⼩者和较⼤者 (算法函数对象)

\noindent \lstinline{minmax_element} (C++11)

返回范围中的最⼩元和最⼤元 (函数模板)

\noindent \lstinline{ranges::minmax_element} (C++20)

返回范围中的最⼩元和最⼤元 (算法函数对象)

\noindent \lstinline{clamp} (C++17)

在⼀对边界值下夹逼⼀个值 (函数模板)

\noindent \lstinline{ranges::clamp} (C++20)

在⼀对边界值下夹逼⼀个值 (算法函数对象)

\noindent \textbf{字典序比较操作}

\textit{在标头 \lstinline{<algorithm>} 定义}


\noindent \lstinline{lexicographical_compare}

当⼀个范围字典序⼩于另⼀个时返回 \lstinline{true} (函数模板)

\noindent \lstinline{ranges::lexicographical_compare} (C++20)

当⼀个范围字典序⼩于另⼀个时返回 \lstinline{true} (算法函数对象)

\noindent \lstinline{lexicographical_compare_three_way} (C++20)

三路⽐较两个范围 (函数模板)

\noindent \textbf{排列操作}

\textit{在标头 \lstinline{<algorithm>} 定义}


\noindent \lstinline{next_permutation}

⽣成元素范围的下⼀个字典序更⼤的排列 (函数模板)

\noindent \lstinline{ranges::next_permutation} (C++20)

⽣成元素范围的下⼀个字典序更⼤的排列 (算法函数对象)

\noindent \lstinline{prev_permutation}

⽣成元素范围的下⼀个字典序更⼩的排列 (函数模板)

\noindent \lstinline{ranges::prev_permutation} (C++20)

⽣成元素范围的下⼀个字典序更⼩的排列 (算法函数对象)

\noindent \lstinline{is_permutation} (C++11)

判断⼀个序列是否为另⼀个序列的排列 (函数模板)

\noindent \lstinline{ranges::is_permutation} (C++20)

判断⼀个序列是否为另⼀个序列的排列 (算法函数对象)

\textbf{数值运算}

\textit{在标头 \lstinline{<numeric>} 定义}


\noindent \lstinline{iota} (C++11)

从初始值开始连续递增填充范围 (函数模板)

\noindent \lstinline{ranges::iota} (C++23)

从初始值开始连续递增填充范围 (算法函数对象)

\noindent \lstinline{accumulate}

求和或折叠范围中元素 (函数模板)

\noindent \lstinline{inner_product}

计算两个范围中元素的内积 (函数模板)

\noindent \lstinline{adjacent_difference}

计算范围中相邻元素的差 (函数模板)

\noindent \lstinline{partial_sum}

计算范围中元素的部分和 (函数模板)

\noindent \lstinline{reduce} (C++17)

类似 \lstinline{std::accumulate}，但不依序执⾏ (函数模板)

\noindent \lstinline{exclusive_scan} (C++17)

类似 \lstinline{std::partial_sum}，第 \lstinline{i} 个和中排除第 \lstinline{i} 个输⼊ (函数模板)

\noindent \lstinline{inclusive_scan} (C++17)

类似 \lstinline{std::partial_sum}，第 \lstinline{i} 个和中包含第 \lstinline{i} 个输⼊ (函数模板)

\noindent \lstinline{transform_reduce} (C++17)

应⽤可调⽤对象，然后乱序规约 (函数模板)

\noindent \lstinline{transform_exclusive_scan} (C++17)

应⽤可调⽤对象，然后计算排除扫描 (函数模板)

\noindent \lstinline{transform_inclusive_scan} (C++17)

应⽤可调⽤对象，然后计算包含扫描 (函数模板)